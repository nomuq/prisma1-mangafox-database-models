// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4466"
var Secret = ""

func (client *Client) Chapter(params ChapterWhereUniqueInput) *ChapterExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ChapterWhereUniqueInput!", "Chapter"},
		"chapter",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

type ChaptersParams struct {
	Where   *ChapterWhereInput   `json:"where,omitempty"`
	OrderBy *ChapterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Chapters(params *ChaptersParams) *ChapterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "Chapter"},
		"chapters",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExecArray{ret}
}

type ChaptersConnectionParams struct {
	Where   *ChapterWhereInput   `json:"where,omitempty"`
	OrderBy *ChapterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ChapterConnection) Nodes() []Chapter {
	var nodes []Chapter
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ChapterConnection) NodesPtr() []*Chapter {
	var nodes []*Chapter
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ChaptersConnection(params *ChaptersConnectionParams) *ChapterConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "Chapter"},
		"chaptersConnection",
		[]string{"edges", "pageInfo"})

	return &ChapterConnectionExec{ret}
}

func (client *Client) Manga(params MangaWhereUniqueInput) *MangaExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"MangaWhereUniqueInput!", "Manga"},
		"manga",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

type MangasParams struct {
	Where   *MangaWhereInput   `json:"where,omitempty"`
	OrderBy *MangaOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Mangas(params *MangasParams) *MangaExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MangaWhereInput", "MangaOrderByInput", "Manga"},
		"mangas",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExecArray{ret}
}

type MangasConnectionParams struct {
	Where   *MangaWhereInput   `json:"where,omitempty"`
	OrderBy *MangaOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *MangaConnection) Nodes() []Manga {
	var nodes []Manga
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *MangaConnection) NodesPtr() []*Manga {
	var nodes []*Manga
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) MangasConnection(params *MangasConnectionParams) *MangaConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MangaWhereInput", "MangaOrderByInput", "Manga"},
		"mangasConnection",
		[]string{"edges", "pageInfo"})

	return &MangaConnectionExec{ret}
}

func (client *Client) CreateChapter(params ChapterCreateInput) *ChapterExec {
	ret := client.Client.Create(
		params,
		[2]string{"ChapterCreateInput!", "Chapter"},
		"createChapter",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

type ChapterUpdateParams struct {
	Data  ChapterUpdateInput      `json:"data"`
	Where ChapterWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateChapter(params ChapterUpdateParams) *ChapterExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ChapterUpdateInput!", "ChapterWhereUniqueInput!", "Chapter"},
		"updateChapter",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

type ChapterUpdateManyParams struct {
	Data  ChapterUpdateManyMutationInput `json:"data"`
	Where *ChapterWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyChapters(params ChapterUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ChapterUpdateManyMutationInput!", "ChapterWhereInput"},
		"updateManyChapters")
	return &BatchPayloadExec{exec}
}

type ChapterUpsertParams struct {
	Where  ChapterWhereUniqueInput `json:"where"`
	Create ChapterCreateInput      `json:"create"`
	Update ChapterUpdateInput      `json:"update"`
}

func (client *Client) UpsertChapter(params ChapterUpsertParams) *ChapterExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ChapterWhereUniqueInput!", "ChapterCreateInput!", "ChapterUpdateInput!", "Chapter"},
		"upsertChapter",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

func (client *Client) DeleteChapter(params ChapterWhereUniqueInput) *ChapterExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ChapterWhereUniqueInput!", "Chapter"},
		"deleteChapter",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

func (client *Client) DeleteManyChapters(params *ChapterWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ChapterWhereInput", "deleteManyChapters")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateManga(params MangaCreateInput) *MangaExec {
	ret := client.Client.Create(
		params,
		[2]string{"MangaCreateInput!", "Manga"},
		"createManga",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

type MangaUpdateParams struct {
	Data  MangaUpdateInput      `json:"data"`
	Where MangaWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateManga(params MangaUpdateParams) *MangaExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"MangaUpdateInput!", "MangaWhereUniqueInput!", "Manga"},
		"updateManga",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

type MangaUpdateManyParams struct {
	Data  MangaUpdateManyMutationInput `json:"data"`
	Where *MangaWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyMangas(params MangaUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"MangaUpdateManyMutationInput!", "MangaWhereInput"},
		"updateManyMangas")
	return &BatchPayloadExec{exec}
}

type MangaUpsertParams struct {
	Where  MangaWhereUniqueInput `json:"where"`
	Create MangaCreateInput      `json:"create"`
	Update MangaUpdateInput      `json:"update"`
}

func (client *Client) UpsertManga(params MangaUpsertParams) *MangaExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"MangaWhereUniqueInput!", "MangaCreateInput!", "MangaUpdateInput!", "Manga"},
		"upsertManga",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

func (client *Client) DeleteManga(params MangaWhereUniqueInput) *MangaExec {
	ret := client.Client.Delete(
		params,
		[2]string{"MangaWhereUniqueInput!", "Manga"},
		"deleteManga",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

func (client *Client) DeleteManyMangas(params *MangaWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "MangaWhereInput", "deleteManyMangas")
	return &BatchPayloadExec{exec}
}

type ChapterOrderByInput string

const (
	ChapterOrderByInputIDAsc         ChapterOrderByInput = "id_ASC"
	ChapterOrderByInputIDDesc        ChapterOrderByInput = "id_DESC"
	ChapterOrderByInputCreatedAtAsc  ChapterOrderByInput = "createdAt_ASC"
	ChapterOrderByInputCreatedAtDesc ChapterOrderByInput = "createdAt_DESC"
	ChapterOrderByInputUpdatedAtAsc  ChapterOrderByInput = "updatedAt_ASC"
	ChapterOrderByInputUpdatedAtDesc ChapterOrderByInput = "updatedAt_DESC"
	ChapterOrderByInputTitleAsc      ChapterOrderByInput = "title_ASC"
	ChapterOrderByInputTitleDesc     ChapterOrderByInput = "title_DESC"
	ChapterOrderByInputNumberAsc     ChapterOrderByInput = "number_ASC"
	ChapterOrderByInputNumberDesc    ChapterOrderByInput = "number_DESC"
	ChapterOrderByInputSourceAsc     ChapterOrderByInput = "source_ASC"
	ChapterOrderByInputSourceDesc    ChapterOrderByInput = "source_DESC"
	ChapterOrderByInputLanguageAsc   ChapterOrderByInput = "language_ASC"
	ChapterOrderByInputLanguageDesc  ChapterOrderByInput = "language_DESC"
)

type MangaOrderByInput string

const (
	MangaOrderByInputIDAsc            MangaOrderByInput = "id_ASC"
	MangaOrderByInputIDDesc           MangaOrderByInput = "id_DESC"
	MangaOrderByInputCreatedAtAsc     MangaOrderByInput = "createdAt_ASC"
	MangaOrderByInputCreatedAtDesc    MangaOrderByInput = "createdAt_DESC"
	MangaOrderByInputUpdatedAtAsc     MangaOrderByInput = "updatedAt_ASC"
	MangaOrderByInputUpdatedAtDesc    MangaOrderByInput = "updatedAt_DESC"
	MangaOrderByInputTitleAsc         MangaOrderByInput = "title_ASC"
	MangaOrderByInputTitleDesc        MangaOrderByInput = "title_DESC"
	MangaOrderByInputDescriptionAsc   MangaOrderByInput = "description_ASC"
	MangaOrderByInputDescriptionDesc  MangaOrderByInput = "description_DESC"
	MangaOrderByInputTypeAsc          MangaOrderByInput = "type_ASC"
	MangaOrderByInputTypeDesc         MangaOrderByInput = "type_DESC"
	MangaOrderByInputBannerAsc        MangaOrderByInput = "banner_ASC"
	MangaOrderByInputBannerDesc       MangaOrderByInput = "banner_DESC"
	MangaOrderByInputIsPublishingAsc  MangaOrderByInput = "isPublishing_ASC"
	MangaOrderByInputIsPublishingDesc MangaOrderByInput = "isPublishing_DESC"
	MangaOrderByInputStartDateAsc     MangaOrderByInput = "startDate_ASC"
	MangaOrderByInputStartDateDesc    MangaOrderByInput = "startDate_DESC"
	MangaOrderByInputEndDateAsc       MangaOrderByInput = "endDate_ASC"
	MangaOrderByInputEndDateDesc      MangaOrderByInput = "endDate_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type ChapterWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ChapterWhereInput struct {
	ID                    *string             `json:"id,omitempty"`
	IDNot                 *string             `json:"id_not,omitempty"`
	IDIn                  []string            `json:"id_in,omitempty"`
	IDNotIn               []string            `json:"id_not_in,omitempty"`
	IDLt                  *string             `json:"id_lt,omitempty"`
	IDLte                 *string             `json:"id_lte,omitempty"`
	IDGt                  *string             `json:"id_gt,omitempty"`
	IDGte                 *string             `json:"id_gte,omitempty"`
	IDContains            *string             `json:"id_contains,omitempty"`
	IDNotContains         *string             `json:"id_not_contains,omitempty"`
	IDStartsWith          *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string             `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string             `json:"createdAt,omitempty"`
	CreatedAtNot          *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string             `json:"updatedAt_gte,omitempty"`
	Title                 *string             `json:"title,omitempty"`
	TitleNot              *string             `json:"title_not,omitempty"`
	TitleIn               []string            `json:"title_in,omitempty"`
	TitleNotIn            []string            `json:"title_not_in,omitempty"`
	TitleLt               *string             `json:"title_lt,omitempty"`
	TitleLte              *string             `json:"title_lte,omitempty"`
	TitleGt               *string             `json:"title_gt,omitempty"`
	TitleGte              *string             `json:"title_gte,omitempty"`
	TitleContains         *string             `json:"title_contains,omitempty"`
	TitleNotContains      *string             `json:"title_not_contains,omitempty"`
	TitleStartsWith       *string             `json:"title_starts_with,omitempty"`
	TitleNotStartsWith    *string             `json:"title_not_starts_with,omitempty"`
	TitleEndsWith         *string             `json:"title_ends_with,omitempty"`
	TitleNotEndsWith      *string             `json:"title_not_ends_with,omitempty"`
	Number                *int32              `json:"number,omitempty"`
	NumberNot             *int32              `json:"number_not,omitempty"`
	NumberIn              []int32             `json:"number_in,omitempty"`
	NumberNotIn           []int32             `json:"number_not_in,omitempty"`
	NumberLt              *int32              `json:"number_lt,omitempty"`
	NumberLte             *int32              `json:"number_lte,omitempty"`
	NumberGt              *int32              `json:"number_gt,omitempty"`
	NumberGte             *int32              `json:"number_gte,omitempty"`
	Source                *string             `json:"source,omitempty"`
	SourceNot             *string             `json:"source_not,omitempty"`
	SourceIn              []string            `json:"source_in,omitempty"`
	SourceNotIn           []string            `json:"source_not_in,omitempty"`
	SourceLt              *string             `json:"source_lt,omitempty"`
	SourceLte             *string             `json:"source_lte,omitempty"`
	SourceGt              *string             `json:"source_gt,omitempty"`
	SourceGte             *string             `json:"source_gte,omitempty"`
	SourceContains        *string             `json:"source_contains,omitempty"`
	SourceNotContains     *string             `json:"source_not_contains,omitempty"`
	SourceStartsWith      *string             `json:"source_starts_with,omitempty"`
	SourceNotStartsWith   *string             `json:"source_not_starts_with,omitempty"`
	SourceEndsWith        *string             `json:"source_ends_with,omitempty"`
	SourceNotEndsWith     *string             `json:"source_not_ends_with,omitempty"`
	Language              *string             `json:"language,omitempty"`
	LanguageNot           *string             `json:"language_not,omitempty"`
	LanguageIn            []string            `json:"language_in,omitempty"`
	LanguageNotIn         []string            `json:"language_not_in,omitempty"`
	LanguageLt            *string             `json:"language_lt,omitempty"`
	LanguageLte           *string             `json:"language_lte,omitempty"`
	LanguageGt            *string             `json:"language_gt,omitempty"`
	LanguageGte           *string             `json:"language_gte,omitempty"`
	LanguageContains      *string             `json:"language_contains,omitempty"`
	LanguageNotContains   *string             `json:"language_not_contains,omitempty"`
	LanguageStartsWith    *string             `json:"language_starts_with,omitempty"`
	LanguageNotStartsWith *string             `json:"language_not_starts_with,omitempty"`
	LanguageEndsWith      *string             `json:"language_ends_with,omitempty"`
	LanguageNotEndsWith   *string             `json:"language_not_ends_with,omitempty"`
	And                   []ChapterWhereInput `json:"AND,omitempty"`
}

type MangaWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type MangaWhereInput struct {
	ID                       *string            `json:"id,omitempty"`
	IDNot                    *string            `json:"id_not,omitempty"`
	IDIn                     []string           `json:"id_in,omitempty"`
	IDNotIn                  []string           `json:"id_not_in,omitempty"`
	IDLt                     *string            `json:"id_lt,omitempty"`
	IDLte                    *string            `json:"id_lte,omitempty"`
	IDGt                     *string            `json:"id_gt,omitempty"`
	IDGte                    *string            `json:"id_gte,omitempty"`
	IDContains               *string            `json:"id_contains,omitempty"`
	IDNotContains            *string            `json:"id_not_contains,omitempty"`
	IDStartsWith             *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string            `json:"id_not_ends_with,omitempty"`
	CreatedAt                *string            `json:"createdAt,omitempty"`
	CreatedAtNot             *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string            `json:"updatedAt_gte,omitempty"`
	Title                    *string            `json:"title,omitempty"`
	TitleNot                 *string            `json:"title_not,omitempty"`
	TitleIn                  []string           `json:"title_in,omitempty"`
	TitleNotIn               []string           `json:"title_not_in,omitempty"`
	TitleLt                  *string            `json:"title_lt,omitempty"`
	TitleLte                 *string            `json:"title_lte,omitempty"`
	TitleGt                  *string            `json:"title_gt,omitempty"`
	TitleGte                 *string            `json:"title_gte,omitempty"`
	TitleContains            *string            `json:"title_contains,omitempty"`
	TitleNotContains         *string            `json:"title_not_contains,omitempty"`
	TitleStartsWith          *string            `json:"title_starts_with,omitempty"`
	TitleNotStartsWith       *string            `json:"title_not_starts_with,omitempty"`
	TitleEndsWith            *string            `json:"title_ends_with,omitempty"`
	TitleNotEndsWith         *string            `json:"title_not_ends_with,omitempty"`
	Description              *string            `json:"description,omitempty"`
	DescriptionNot           *string            `json:"description_not,omitempty"`
	DescriptionIn            []string           `json:"description_in,omitempty"`
	DescriptionNotIn         []string           `json:"description_not_in,omitempty"`
	DescriptionLt            *string            `json:"description_lt,omitempty"`
	DescriptionLte           *string            `json:"description_lte,omitempty"`
	DescriptionGt            *string            `json:"description_gt,omitempty"`
	DescriptionGte           *string            `json:"description_gte,omitempty"`
	DescriptionContains      *string            `json:"description_contains,omitempty"`
	DescriptionNotContains   *string            `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string            `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string            `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string            `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string            `json:"description_not_ends_with,omitempty"`
	Type                     *string            `json:"type,omitempty"`
	TypeNot                  *string            `json:"type_not,omitempty"`
	TypeIn                   []string           `json:"type_in,omitempty"`
	TypeNotIn                []string           `json:"type_not_in,omitempty"`
	TypeLt                   *string            `json:"type_lt,omitempty"`
	TypeLte                  *string            `json:"type_lte,omitempty"`
	TypeGt                   *string            `json:"type_gt,omitempty"`
	TypeGte                  *string            `json:"type_gte,omitempty"`
	TypeContains             *string            `json:"type_contains,omitempty"`
	TypeNotContains          *string            `json:"type_not_contains,omitempty"`
	TypeStartsWith           *string            `json:"type_starts_with,omitempty"`
	TypeNotStartsWith        *string            `json:"type_not_starts_with,omitempty"`
	TypeEndsWith             *string            `json:"type_ends_with,omitempty"`
	TypeNotEndsWith          *string            `json:"type_not_ends_with,omitempty"`
	Cover                    *CoverWhereInput   `json:"cover,omitempty"`
	Banner                   *string            `json:"banner,omitempty"`
	BannerNot                *string            `json:"banner_not,omitempty"`
	BannerIn                 []string           `json:"banner_in,omitempty"`
	BannerNotIn              []string           `json:"banner_not_in,omitempty"`
	BannerLt                 *string            `json:"banner_lt,omitempty"`
	BannerLte                *string            `json:"banner_lte,omitempty"`
	BannerGt                 *string            `json:"banner_gt,omitempty"`
	BannerGte                *string            `json:"banner_gte,omitempty"`
	BannerContains           *string            `json:"banner_contains,omitempty"`
	BannerNotContains        *string            `json:"banner_not_contains,omitempty"`
	BannerStartsWith         *string            `json:"banner_starts_with,omitempty"`
	BannerNotStartsWith      *string            `json:"banner_not_starts_with,omitempty"`
	BannerEndsWith           *string            `json:"banner_ends_with,omitempty"`
	BannerNotEndsWith        *string            `json:"banner_not_ends_with,omitempty"`
	Links                    *LinkWhereInput    `json:"links,omitempty"`
	IsPublishing             *bool              `json:"isPublishing,omitempty"`
	IsPublishingNot          *bool              `json:"isPublishing_not,omitempty"`
	StartDate                *string            `json:"startDate,omitempty"`
	StartDateNot             *string            `json:"startDate_not,omitempty"`
	StartDateIn              []string           `json:"startDate_in,omitempty"`
	StartDateNotIn           []string           `json:"startDate_not_in,omitempty"`
	StartDateLt              *string            `json:"startDate_lt,omitempty"`
	StartDateLte             *string            `json:"startDate_lte,omitempty"`
	StartDateGt              *string            `json:"startDate_gt,omitempty"`
	StartDateGte             *string            `json:"startDate_gte,omitempty"`
	EndDate                  *string            `json:"endDate,omitempty"`
	EndDateNot               *string            `json:"endDate_not,omitempty"`
	EndDateIn                []string           `json:"endDate_in,omitempty"`
	EndDateNotIn             []string           `json:"endDate_not_in,omitempty"`
	EndDateLt                *string            `json:"endDate_lt,omitempty"`
	EndDateLte               *string            `json:"endDate_lte,omitempty"`
	EndDateGt                *string            `json:"endDate_gt,omitempty"`
	EndDateGte               *string            `json:"endDate_gte,omitempty"`
	ChaptersSome             *ChapterWhereInput `json:"chapters_some,omitempty"`
	And                      []MangaWhereInput  `json:"AND,omitempty"`
}

type CoverWhereInput struct {
	Color                   *string           `json:"color,omitempty"`
	ColorNot                *string           `json:"color_not,omitempty"`
	ColorIn                 []string          `json:"color_in,omitempty"`
	ColorNotIn              []string          `json:"color_not_in,omitempty"`
	ColorLt                 *string           `json:"color_lt,omitempty"`
	ColorLte                *string           `json:"color_lte,omitempty"`
	ColorGt                 *string           `json:"color_gt,omitempty"`
	ColorGte                *string           `json:"color_gte,omitempty"`
	ColorContains           *string           `json:"color_contains,omitempty"`
	ColorNotContains        *string           `json:"color_not_contains,omitempty"`
	ColorStartsWith         *string           `json:"color_starts_with,omitempty"`
	ColorNotStartsWith      *string           `json:"color_not_starts_with,omitempty"`
	ColorEndsWith           *string           `json:"color_ends_with,omitempty"`
	ColorNotEndsWith        *string           `json:"color_not_ends_with,omitempty"`
	Extralarge              *string           `json:"extralarge,omitempty"`
	ExtralargeNot           *string           `json:"extralarge_not,omitempty"`
	ExtralargeIn            []string          `json:"extralarge_in,omitempty"`
	ExtralargeNotIn         []string          `json:"extralarge_not_in,omitempty"`
	ExtralargeLt            *string           `json:"extralarge_lt,omitempty"`
	ExtralargeLte           *string           `json:"extralarge_lte,omitempty"`
	ExtralargeGt            *string           `json:"extralarge_gt,omitempty"`
	ExtralargeGte           *string           `json:"extralarge_gte,omitempty"`
	ExtralargeContains      *string           `json:"extralarge_contains,omitempty"`
	ExtralargeNotContains   *string           `json:"extralarge_not_contains,omitempty"`
	ExtralargeStartsWith    *string           `json:"extralarge_starts_with,omitempty"`
	ExtralargeNotStartsWith *string           `json:"extralarge_not_starts_with,omitempty"`
	ExtralargeEndsWith      *string           `json:"extralarge_ends_with,omitempty"`
	ExtralargeNotEndsWith   *string           `json:"extralarge_not_ends_with,omitempty"`
	Large                   *string           `json:"large,omitempty"`
	LargeNot                *string           `json:"large_not,omitempty"`
	LargeIn                 []string          `json:"large_in,omitempty"`
	LargeNotIn              []string          `json:"large_not_in,omitempty"`
	LargeLt                 *string           `json:"large_lt,omitempty"`
	LargeLte                *string           `json:"large_lte,omitempty"`
	LargeGt                 *string           `json:"large_gt,omitempty"`
	LargeGte                *string           `json:"large_gte,omitempty"`
	LargeContains           *string           `json:"large_contains,omitempty"`
	LargeNotContains        *string           `json:"large_not_contains,omitempty"`
	LargeStartsWith         *string           `json:"large_starts_with,omitempty"`
	LargeNotStartsWith      *string           `json:"large_not_starts_with,omitempty"`
	LargeEndsWith           *string           `json:"large_ends_with,omitempty"`
	LargeNotEndsWith        *string           `json:"large_not_ends_with,omitempty"`
	Medium                  *string           `json:"medium,omitempty"`
	MediumNot               *string           `json:"medium_not,omitempty"`
	MediumIn                []string          `json:"medium_in,omitempty"`
	MediumNotIn             []string          `json:"medium_not_in,omitempty"`
	MediumLt                *string           `json:"medium_lt,omitempty"`
	MediumLte               *string           `json:"medium_lte,omitempty"`
	MediumGt                *string           `json:"medium_gt,omitempty"`
	MediumGte               *string           `json:"medium_gte,omitempty"`
	MediumContains          *string           `json:"medium_contains,omitempty"`
	MediumNotContains       *string           `json:"medium_not_contains,omitempty"`
	MediumStartsWith        *string           `json:"medium_starts_with,omitempty"`
	MediumNotStartsWith     *string           `json:"medium_not_starts_with,omitempty"`
	MediumEndsWith          *string           `json:"medium_ends_with,omitempty"`
	MediumNotEndsWith       *string           `json:"medium_not_ends_with,omitempty"`
	And                     []CoverWhereInput `json:"AND,omitempty"`
}

type LinkWhereInput struct {
	Anilist                  *string          `json:"anilist,omitempty"`
	AnilistNot               *string          `json:"anilist_not,omitempty"`
	AnilistIn                []string         `json:"anilist_in,omitempty"`
	AnilistNotIn             []string         `json:"anilist_not_in,omitempty"`
	AnilistLt                *string          `json:"anilist_lt,omitempty"`
	AnilistLte               *string          `json:"anilist_lte,omitempty"`
	AnilistGt                *string          `json:"anilist_gt,omitempty"`
	AnilistGte               *string          `json:"anilist_gte,omitempty"`
	AnilistContains          *string          `json:"anilist_contains,omitempty"`
	AnilistNotContains       *string          `json:"anilist_not_contains,omitempty"`
	AnilistStartsWith        *string          `json:"anilist_starts_with,omitempty"`
	AnilistNotStartsWith     *string          `json:"anilist_not_starts_with,omitempty"`
	AnilistEndsWith          *string          `json:"anilist_ends_with,omitempty"`
	AnilistNotEndsWith       *string          `json:"anilist_not_ends_with,omitempty"`
	Mal                      *string          `json:"mal,omitempty"`
	MalNot                   *string          `json:"mal_not,omitempty"`
	MalIn                    []string         `json:"mal_in,omitempty"`
	MalNotIn                 []string         `json:"mal_not_in,omitempty"`
	MalLt                    *string          `json:"mal_lt,omitempty"`
	MalLte                   *string          `json:"mal_lte,omitempty"`
	MalGt                    *string          `json:"mal_gt,omitempty"`
	MalGte                   *string          `json:"mal_gte,omitempty"`
	MalContains              *string          `json:"mal_contains,omitempty"`
	MalNotContains           *string          `json:"mal_not_contains,omitempty"`
	MalStartsWith            *string          `json:"mal_starts_with,omitempty"`
	MalNotStartsWith         *string          `json:"mal_not_starts_with,omitempty"`
	MalEndsWith              *string          `json:"mal_ends_with,omitempty"`
	MalNotEndsWith           *string          `json:"mal_not_ends_with,omitempty"`
	Mangadex                 *string          `json:"mangadex,omitempty"`
	MangadexNot              *string          `json:"mangadex_not,omitempty"`
	MangadexIn               []string         `json:"mangadex_in,omitempty"`
	MangadexNotIn            []string         `json:"mangadex_not_in,omitempty"`
	MangadexLt               *string          `json:"mangadex_lt,omitempty"`
	MangadexLte              *string          `json:"mangadex_lte,omitempty"`
	MangadexGt               *string          `json:"mangadex_gt,omitempty"`
	MangadexGte              *string          `json:"mangadex_gte,omitempty"`
	MangadexContains         *string          `json:"mangadex_contains,omitempty"`
	MangadexNotContains      *string          `json:"mangadex_not_contains,omitempty"`
	MangadexStartsWith       *string          `json:"mangadex_starts_with,omitempty"`
	MangadexNotStartsWith    *string          `json:"mangadex_not_starts_with,omitempty"`
	MangadexEndsWith         *string          `json:"mangadex_ends_with,omitempty"`
	MangadexNotEndsWith      *string          `json:"mangadex_not_ends_with,omitempty"`
	Mangareader              *string          `json:"mangareader,omitempty"`
	MangareaderNot           *string          `json:"mangareader_not,omitempty"`
	MangareaderIn            []string         `json:"mangareader_in,omitempty"`
	MangareaderNotIn         []string         `json:"mangareader_not_in,omitempty"`
	MangareaderLt            *string          `json:"mangareader_lt,omitempty"`
	MangareaderLte           *string          `json:"mangareader_lte,omitempty"`
	MangareaderGt            *string          `json:"mangareader_gt,omitempty"`
	MangareaderGte           *string          `json:"mangareader_gte,omitempty"`
	MangareaderContains      *string          `json:"mangareader_contains,omitempty"`
	MangareaderNotContains   *string          `json:"mangareader_not_contains,omitempty"`
	MangareaderStartsWith    *string          `json:"mangareader_starts_with,omitempty"`
	MangareaderNotStartsWith *string          `json:"mangareader_not_starts_with,omitempty"`
	MangareaderEndsWith      *string          `json:"mangareader_ends_with,omitempty"`
	MangareaderNotEndsWith   *string          `json:"mangareader_not_ends_with,omitempty"`
	And                      []LinkWhereInput `json:"AND,omitempty"`
}

type ChapterCreateInput struct {
	ID       *string                  `json:"id,omitempty"`
	Title    *string                  `json:"title,omitempty"`
	Number   int32                    `json:"number"`
	Links    *ChapterCreatelinksInput `json:"links,omitempty"`
	Source   string                   `json:"source"`
	Language *string                  `json:"language,omitempty"`
}

type ChapterCreatelinksInput struct {
	Set []string `json:"set,omitempty"`
}

type ChapterUpdateInput struct {
	Title    *string                  `json:"title,omitempty"`
	Number   *int32                   `json:"number,omitempty"`
	Links    *ChapterUpdatelinksInput `json:"links,omitempty"`
	Source   *string                  `json:"source,omitempty"`
	Language *string                  `json:"language,omitempty"`
}

type ChapterUpdatelinksInput struct {
	Set []string `json:"set,omitempty"`
}

type ChapterUpdateManyMutationInput struct {
	Title    *string                  `json:"title,omitempty"`
	Number   *int32                   `json:"number,omitempty"`
	Links    *ChapterUpdatelinksInput `json:"links,omitempty"`
	Source   *string                  `json:"source,omitempty"`
	Language *string                  `json:"language,omitempty"`
}

type MangaCreateInput struct {
	ID           *string                   `json:"id,omitempty"`
	Title        string                    `json:"title"`
	Description  *string                   `json:"description,omitempty"`
	Genres       *MangaCreategenresInput   `json:"genres,omitempty"`
	Tags         *MangaCreatetagsInput     `json:"tags,omitempty"`
	Synonyms     *MangaCreatesynonymsInput `json:"synonyms,omitempty"`
	Type         *string                   `json:"type,omitempty"`
	Cover        *CoverCreateOneInput      `json:"cover,omitempty"`
	Banner       *string                   `json:"banner,omitempty"`
	Links        *LinkCreateOneInput       `json:"links,omitempty"`
	IsPublishing *bool                     `json:"isPublishing,omitempty"`
	StartDate    *string                   `json:"startDate,omitempty"`
	EndDate      *string                   `json:"endDate,omitempty"`
	Chapters     *ChapterCreateManyInput   `json:"chapters,omitempty"`
}

type MangaCreategenresInput struct {
	Set []string `json:"set,omitempty"`
}

type MangaCreatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type MangaCreatesynonymsInput struct {
	Set []string `json:"set,omitempty"`
}

type CoverCreateOneInput struct {
	Create *CoverCreateInput `json:"create,omitempty"`
}

type CoverCreateInput struct {
	Color      *string `json:"color,omitempty"`
	Extralarge *string `json:"extralarge,omitempty"`
	Large      *string `json:"large,omitempty"`
	Medium     *string `json:"medium,omitempty"`
}

type LinkCreateOneInput struct {
	Create *LinkCreateInput `json:"create,omitempty"`
}

type LinkCreateInput struct {
	Anilist     *string `json:"anilist,omitempty"`
	Mal         *string `json:"mal,omitempty"`
	Mangadex    *string `json:"mangadex,omitempty"`
	Mangareader *string `json:"mangareader,omitempty"`
}

type ChapterCreateManyInput struct {
	Create  []ChapterCreateInput      `json:"create,omitempty"`
	Connect []ChapterWhereUniqueInput `json:"connect,omitempty"`
}

type MangaUpdateInput struct {
	Title        *string                   `json:"title,omitempty"`
	Description  *string                   `json:"description,omitempty"`
	Genres       *MangaUpdategenresInput   `json:"genres,omitempty"`
	Tags         *MangaUpdatetagsInput     `json:"tags,omitempty"`
	Synonyms     *MangaUpdatesynonymsInput `json:"synonyms,omitempty"`
	Type         *string                   `json:"type,omitempty"`
	Cover        *CoverUpdateOneInput      `json:"cover,omitempty"`
	Banner       *string                   `json:"banner,omitempty"`
	Links        *LinkUpdateOneInput       `json:"links,omitempty"`
	IsPublishing *bool                     `json:"isPublishing,omitempty"`
	StartDate    *string                   `json:"startDate,omitempty"`
	EndDate      *string                   `json:"endDate,omitempty"`
	Chapters     *ChapterUpdateManyInput   `json:"chapters,omitempty"`
}

type MangaUpdategenresInput struct {
	Set []string `json:"set,omitempty"`
}

type MangaUpdatetagsInput struct {
	Set []string `json:"set,omitempty"`
}

type MangaUpdatesynonymsInput struct {
	Set []string `json:"set,omitempty"`
}

type CoverUpdateOneInput struct {
	Create     *CoverCreateInput       `json:"create,omitempty"`
	Update     *CoverUpdateDataInput   `json:"update,omitempty"`
	Upsert     *CoverUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                   `json:"delete,omitempty"`
	Disconnect *bool                   `json:"disconnect,omitempty"`
}

type CoverUpdateDataInput struct {
	Color      *string `json:"color,omitempty"`
	Extralarge *string `json:"extralarge,omitempty"`
	Large      *string `json:"large,omitempty"`
	Medium     *string `json:"medium,omitempty"`
}

type CoverUpsertNestedInput struct {
	Update CoverUpdateDataInput `json:"update"`
	Create CoverCreateInput     `json:"create"`
}

type LinkUpdateOneInput struct {
	Create     *LinkCreateInput       `json:"create,omitempty"`
	Update     *LinkUpdateDataInput   `json:"update,omitempty"`
	Upsert     *LinkUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
}

type LinkUpdateDataInput struct {
	Anilist     *string `json:"anilist,omitempty"`
	Mal         *string `json:"mal,omitempty"`
	Mangadex    *string `json:"mangadex,omitempty"`
	Mangareader *string `json:"mangareader,omitempty"`
}

type LinkUpsertNestedInput struct {
	Update LinkUpdateDataInput `json:"update"`
	Create LinkCreateInput     `json:"create"`
}

type ChapterUpdateManyInput struct {
	Create     []ChapterCreateInput                      `json:"create,omitempty"`
	Update     []ChapterUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ChapterUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ChapterWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ChapterWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ChapterWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ChapterWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ChapterScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ChapterUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type ChapterUpdateWithWhereUniqueNestedInput struct {
	Where ChapterWhereUniqueInput `json:"where"`
	Data  ChapterUpdateDataInput  `json:"data"`
}

type ChapterUpdateDataInput struct {
	Title    *string                  `json:"title,omitempty"`
	Number   *int32                   `json:"number,omitempty"`
	Links    *ChapterUpdatelinksInput `json:"links,omitempty"`
	Source   *string                  `json:"source,omitempty"`
	Language *string                  `json:"language,omitempty"`
}

type ChapterUpsertWithWhereUniqueNestedInput struct {
	Where  ChapterWhereUniqueInput `json:"where"`
	Update ChapterUpdateDataInput  `json:"update"`
	Create ChapterCreateInput      `json:"create"`
}

type ChapterScalarWhereInput struct {
	ID                    *string                   `json:"id,omitempty"`
	IDNot                 *string                   `json:"id_not,omitempty"`
	IDIn                  []string                  `json:"id_in,omitempty"`
	IDNotIn               []string                  `json:"id_not_in,omitempty"`
	IDLt                  *string                   `json:"id_lt,omitempty"`
	IDLte                 *string                   `json:"id_lte,omitempty"`
	IDGt                  *string                   `json:"id_gt,omitempty"`
	IDGte                 *string                   `json:"id_gte,omitempty"`
	IDContains            *string                   `json:"id_contains,omitempty"`
	IDNotContains         *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt             *string                   `json:"createdAt,omitempty"`
	CreatedAtNot          *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                   `json:"updatedAt_gte,omitempty"`
	Title                 *string                   `json:"title,omitempty"`
	TitleNot              *string                   `json:"title_not,omitempty"`
	TitleIn               []string                  `json:"title_in,omitempty"`
	TitleNotIn            []string                  `json:"title_not_in,omitempty"`
	TitleLt               *string                   `json:"title_lt,omitempty"`
	TitleLte              *string                   `json:"title_lte,omitempty"`
	TitleGt               *string                   `json:"title_gt,omitempty"`
	TitleGte              *string                   `json:"title_gte,omitempty"`
	TitleContains         *string                   `json:"title_contains,omitempty"`
	TitleNotContains      *string                   `json:"title_not_contains,omitempty"`
	TitleStartsWith       *string                   `json:"title_starts_with,omitempty"`
	TitleNotStartsWith    *string                   `json:"title_not_starts_with,omitempty"`
	TitleEndsWith         *string                   `json:"title_ends_with,omitempty"`
	TitleNotEndsWith      *string                   `json:"title_not_ends_with,omitempty"`
	Number                *int32                    `json:"number,omitempty"`
	NumberNot             *int32                    `json:"number_not,omitempty"`
	NumberIn              []int32                   `json:"number_in,omitempty"`
	NumberNotIn           []int32                   `json:"number_not_in,omitempty"`
	NumberLt              *int32                    `json:"number_lt,omitempty"`
	NumberLte             *int32                    `json:"number_lte,omitempty"`
	NumberGt              *int32                    `json:"number_gt,omitempty"`
	NumberGte             *int32                    `json:"number_gte,omitempty"`
	Source                *string                   `json:"source,omitempty"`
	SourceNot             *string                   `json:"source_not,omitempty"`
	SourceIn              []string                  `json:"source_in,omitempty"`
	SourceNotIn           []string                  `json:"source_not_in,omitempty"`
	SourceLt              *string                   `json:"source_lt,omitempty"`
	SourceLte             *string                   `json:"source_lte,omitempty"`
	SourceGt              *string                   `json:"source_gt,omitempty"`
	SourceGte             *string                   `json:"source_gte,omitempty"`
	SourceContains        *string                   `json:"source_contains,omitempty"`
	SourceNotContains     *string                   `json:"source_not_contains,omitempty"`
	SourceStartsWith      *string                   `json:"source_starts_with,omitempty"`
	SourceNotStartsWith   *string                   `json:"source_not_starts_with,omitempty"`
	SourceEndsWith        *string                   `json:"source_ends_with,omitempty"`
	SourceNotEndsWith     *string                   `json:"source_not_ends_with,omitempty"`
	Language              *string                   `json:"language,omitempty"`
	LanguageNot           *string                   `json:"language_not,omitempty"`
	LanguageIn            []string                  `json:"language_in,omitempty"`
	LanguageNotIn         []string                  `json:"language_not_in,omitempty"`
	LanguageLt            *string                   `json:"language_lt,omitempty"`
	LanguageLte           *string                   `json:"language_lte,omitempty"`
	LanguageGt            *string                   `json:"language_gt,omitempty"`
	LanguageGte           *string                   `json:"language_gte,omitempty"`
	LanguageContains      *string                   `json:"language_contains,omitempty"`
	LanguageNotContains   *string                   `json:"language_not_contains,omitempty"`
	LanguageStartsWith    *string                   `json:"language_starts_with,omitempty"`
	LanguageNotStartsWith *string                   `json:"language_not_starts_with,omitempty"`
	LanguageEndsWith      *string                   `json:"language_ends_with,omitempty"`
	LanguageNotEndsWith   *string                   `json:"language_not_ends_with,omitempty"`
	And                   []ChapterScalarWhereInput `json:"AND,omitempty"`
	Or                    []ChapterScalarWhereInput `json:"OR,omitempty"`
	Not                   []ChapterScalarWhereInput `json:"NOT,omitempty"`
}

type ChapterUpdateManyWithWhereNestedInput struct {
	Where ChapterScalarWhereInput    `json:"where"`
	Data  ChapterUpdateManyDataInput `json:"data"`
}

type ChapterUpdateManyDataInput struct {
	Title    *string                  `json:"title,omitempty"`
	Number   *int32                   `json:"number,omitempty"`
	Links    *ChapterUpdatelinksInput `json:"links,omitempty"`
	Source   *string                  `json:"source,omitempty"`
	Language *string                  `json:"language,omitempty"`
}

type MangaUpdateManyMutationInput struct {
	Title        *string                   `json:"title,omitempty"`
	Description  *string                   `json:"description,omitempty"`
	Genres       *MangaUpdategenresInput   `json:"genres,omitempty"`
	Tags         *MangaUpdatetagsInput     `json:"tags,omitempty"`
	Synonyms     *MangaUpdatesynonymsInput `json:"synonyms,omitempty"`
	Type         *string                   `json:"type,omitempty"`
	Banner       *string                   `json:"banner,omitempty"`
	IsPublishing *bool                     `json:"isPublishing,omitempty"`
	StartDate    *string                   `json:"startDate,omitempty"`
	EndDate      *string                   `json:"endDate,omitempty"`
}

type ChapterSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ChapterWhereInput              `json:"node,omitempty"`
	And                        []ChapterSubscriptionWhereInput `json:"AND,omitempty"`
}

type MangaSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *MangaWhereInput              `json:"node,omitempty"`
	And                        []MangaSubscriptionWhereInput `json:"AND,omitempty"`
}

type ChapterExec struct {
	exec *prisma.Exec
}

func (instance ChapterExec) Exec(ctx context.Context) (*Chapter, error) {
	var v Chapter
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterExecArray) Exec(ctx context.Context) ([]Chapter, error) {
	var v []Chapter
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ChapterFields = []string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"}

type Chapter struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	Title     *string  `json:"title,omitempty"`
	Number    int32    `json:"number"`
	Links     []string `json:"links,omitempty"`
	Source    string   `json:"source"`
	Language  string   `json:"language"`
}

type ChapterConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ChapterConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ChapterConnectionExec) Edges() *ChapterEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "ChapterEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Chapter"},
		"node",
		ChapterFields)

	return &ChapterEdgeExecArray{nodes}
}

func (instance *ChapterConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateChapter"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ChapterConnectionExec) Exec(ctx context.Context) (*ChapterConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ChapterConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ChapterConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterConnectionExecArray) Exec(ctx context.Context) ([]ChapterConnection, error) {
	var v []ChapterConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ChapterConnectionFields = []string{}

type ChapterConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []ChapterEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type ChapterEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ChapterEdgeExec) Node() *ChapterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chapter"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

func (instance ChapterEdgeExec) Exec(ctx context.Context) (*ChapterEdge, error) {
	var v ChapterEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterEdgeExecArray) Exec(ctx context.Context) ([]ChapterEdge, error) {
	var v []ChapterEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ChapterEdgeFields = []string{"cursor"}

type ChapterEdge struct {
	Node   Chapter `json:"node"`
	Cursor string  `json:"cursor"`
}

type MangaExec struct {
	exec *prisma.Exec
}

func (instance *MangaExec) Cover() *CoverExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Cover"},
		"cover",
		[]string{"color", "extralarge", "large", "medium"})

	return &CoverExec{ret}
}

func (instance *MangaExec) Links() *LinkExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Link"},
		"links",
		[]string{"anilist", "mal", "mangadex", "mangareader"})

	return &LinkExec{ret}
}

type ChaptersParamsExec struct {
	Where   *ChapterWhereInput
	OrderBy *ChapterOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *MangaExec) Chapters(params *ChaptersParamsExec) *ChapterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ChapterWhereInput", "ChapterOrderByInput", "Chapter"},
		"chapters",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExecArray{ret}
}

func (instance MangaExec) Exec(ctx context.Context) (*Manga, error) {
	var v Manga
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MangaExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MangaExecArray struct {
	exec *prisma.Exec
}

func (instance MangaExecArray) Exec(ctx context.Context) ([]Manga, error) {
	var v []Manga
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MangaFields = []string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"}

type Manga struct {
	ID           string   `json:"id"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Title        string   `json:"title"`
	Description  *string  `json:"description,omitempty"`
	Genres       []string `json:"genres,omitempty"`
	Tags         []string `json:"tags,omitempty"`
	Synonyms     []string `json:"synonyms,omitempty"`
	Type         *string  `json:"type,omitempty"`
	Banner       *string  `json:"banner,omitempty"`
	IsPublishing bool     `json:"isPublishing"`
	StartDate    *string  `json:"startDate,omitempty"`
	EndDate      *string  `json:"endDate,omitempty"`
}

type CoverExec struct {
	exec *prisma.Exec
}

func (instance CoverExec) Exec(ctx context.Context) (*Cover, error) {
	var v Cover
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoverExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoverExecArray struct {
	exec *prisma.Exec
}

func (instance CoverExecArray) Exec(ctx context.Context) ([]Cover, error) {
	var v []Cover
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoverFields = []string{"color", "extralarge", "large", "medium"}

type Cover struct {
	Color      *string `json:"color,omitempty"`
	Extralarge *string `json:"extralarge,omitempty"`
	Large      *string `json:"large,omitempty"`
	Medium     *string `json:"medium,omitempty"`
}

type LinkExec struct {
	exec *prisma.Exec
}

func (instance LinkExec) Exec(ctx context.Context) (*Link, error) {
	var v Link
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance LinkExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type LinkExecArray struct {
	exec *prisma.Exec
}

func (instance LinkExecArray) Exec(ctx context.Context) ([]Link, error) {
	var v []Link
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var LinkFields = []string{"anilist", "mal", "mangadex", "mangareader"}

type Link struct {
	Anilist     *string `json:"anilist,omitempty"`
	Mal         *string `json:"mal,omitempty"`
	Mangadex    *string `json:"mangadex,omitempty"`
	Mangareader *string `json:"mangareader,omitempty"`
}

type MangaConnectionExec struct {
	exec *prisma.Exec
}

func (instance *MangaConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *MangaConnectionExec) Edges() *MangaEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"MangaWhereInput", "MangaOrderByInput", "MangaEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Manga"},
		"node",
		MangaFields)

	return &MangaEdgeExecArray{nodes}
}

func (instance *MangaConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateManga"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance MangaConnectionExec) Exec(ctx context.Context) (*MangaConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &MangaConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance MangaConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MangaConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance MangaConnectionExecArray) Exec(ctx context.Context) ([]MangaConnection, error) {
	var v []MangaConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MangaConnectionFields = []string{}

type MangaConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []MangaEdge `json:"edges"`
}

type MangaEdgeExec struct {
	exec *prisma.Exec
}

func (instance *MangaEdgeExec) Node() *MangaExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Manga"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

func (instance MangaEdgeExec) Exec(ctx context.Context) (*MangaEdge, error) {
	var v MangaEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MangaEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MangaEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance MangaEdgeExecArray) Exec(ctx context.Context) ([]MangaEdge, error) {
	var v []MangaEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MangaEdgeFields = []string{"cursor"}

type MangaEdge struct {
	Node   Manga  `json:"node"`
	Cursor string `json:"cursor"`
}

type ChapterSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ChapterSubscriptionPayloadExec) Node() *ChapterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Chapter"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterExec{ret}
}

func (instance *ChapterSubscriptionPayloadExec) PreviousValues() *ChapterPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ChapterPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"})

	return &ChapterPreviousValuesExec{ret}
}

func (instance ChapterSubscriptionPayloadExec) Exec(ctx context.Context) (*ChapterSubscriptionPayload, error) {
	var v ChapterSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ChapterSubscriptionPayload, error) {
	var v []ChapterSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ChapterSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ChapterSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Chapter     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ChapterPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ChapterPreviousValuesExec) Exec(ctx context.Context) (*ChapterPreviousValues, error) {
	var v ChapterPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ChapterPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ChapterPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ChapterPreviousValuesExecArray) Exec(ctx context.Context) ([]ChapterPreviousValues, error) {
	var v []ChapterPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ChapterPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "title", "number", "links", "source", "language"}

type ChapterPreviousValues struct {
	ID        string   `json:"id"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
	Title     *string  `json:"title,omitempty"`
	Number    int32    `json:"number"`
	Links     []string `json:"links,omitempty"`
	Source    string   `json:"source"`
	Language  string   `json:"language"`
}

type MangaSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *MangaSubscriptionPayloadExec) Node() *MangaExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Manga"},
		"node",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaExec{ret}
}

func (instance *MangaSubscriptionPayloadExec) PreviousValues() *MangaPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MangaPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"})

	return &MangaPreviousValuesExec{ret}
}

func (instance MangaSubscriptionPayloadExec) Exec(ctx context.Context) (*MangaSubscriptionPayload, error) {
	var v MangaSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MangaSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MangaSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance MangaSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MangaSubscriptionPayload, error) {
	var v []MangaSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MangaSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type MangaSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Manga       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type MangaPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance MangaPreviousValuesExec) Exec(ctx context.Context) (*MangaPreviousValues, error) {
	var v MangaPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MangaPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MangaPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance MangaPreviousValuesExecArray) Exec(ctx context.Context) ([]MangaPreviousValues, error) {
	var v []MangaPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MangaPreviousValuesFields = []string{"id", "createdAt", "updatedAt", "title", "description", "genres", "tags", "synonyms", "type", "banner", "isPublishing", "startDate", "endDate"}

type MangaPreviousValues struct {
	ID           string   `json:"id"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
	Title        string   `json:"title"`
	Description  *string  `json:"description,omitempty"`
	Genres       []string `json:"genres,omitempty"`
	Tags         []string `json:"tags,omitempty"`
	Synonyms     []string `json:"synonyms,omitempty"`
	Type         *string  `json:"type,omitempty"`
	Banner       *string  `json:"banner,omitempty"`
	IsPublishing bool     `json:"isPublishing"`
	StartDate    *string  `json:"startDate,omitempty"`
	EndDate      *string  `json:"endDate,omitempty"`
}
